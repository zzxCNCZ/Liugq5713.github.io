# 全排列生成算法

## 字典序法

### 算法步骤

设 P 是集合{1，2，……n-1，n}的一个全排列：P=P1P2……Pj-1PjPj+1……Pn（1≤P1，P2，……，Pn≤n-1）

从排列的右端开始，找出第一个比右边数字小的数字的序号 j，即 j=max{i|Pi<Pi+1，i>j}
在 Pj 的右边的数字中，找出所有比 Pj 大的数字中最小的数字 Pk，即 k=min{i|Pi>Pj，i>j}
交换 Pj，Pk
再将排列右端的递减部分 Pj+1Pj+2……Pn 倒转，因为 j 右端的数字是降序，所以只需要其左边和右边的交换，直到中间，因此可以得到一个新的排列 P'=P1P2……Pj-1PkPn……Pj+2Pj+1。

### 算法正确性证明

证明它可以生成所有的排列只需要证明生成的下一个排序恰好比当前排列大的一个序列即可。对于任意 j，作为从右端开始第一个小于左边数字的数，可以得到序列 Pj+1，...Pn 是降序排列，选择其中大于 Pj 的最小的数字 Pk，与其交换，然后再对后面排序得到序列 P1，...Pj-1Pk...Pn，恰好比 P1...Pj-1Pj...Pn 大一点的下一个排列，因此算法可以生成全排列。

<<< @/algorithm/violence/code/all-permutation-dict.js

## 插入法

如果已知 n-1 个元素的排列，将 n 插入到排列的不同位置，就得到了 n 个元素的排列。用这种方法可以产生出任意 n 个元素的排列。这个方法有一个缺点：为了产生 n 个元素的排列，我们必须知道并存储所有 n-1 个元素的排列，然后才能产生出所有 n 阶排列

<<< @/algorithm/violence/code/all-permutations.js

## 回溯法

在按某种搜索策略搜索的过程中，当到达某一状态时，继续向前搜索已经确定不会得到正确答案的情况下，可以返回上一搜索状态，沿着新的可能性继续搜索。其求解过程的实质是一个先序遍历一棵“状态树”的过程

### 爬楼梯问题

对于一个与 n 级台阶组成的楼梯，爬楼梯时一次可以上 1 级台阶或 2 级台阶。共有多少种不同的走法。

### 八皇后问题

在国际象棋棋盘 8 × 8 上放置八个皇后，使得任意两个皇后之间不能在同一行，同一列，也不能位于同于对角线上。问共有多少种不同的方法，并且指出各种不同的放法

## 参考

- [46. Permutations](https://leetcode.com/problems/permutations/discuss/18308/JavaScript-using-DP)
- [Wikipedia 全排列生成算法](https://zh.wikipedia.org/wiki/%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95)
- [漫画：什么是八皇后问题？](https://juejin.im/post/5accdb236fb9a028bb195562)
