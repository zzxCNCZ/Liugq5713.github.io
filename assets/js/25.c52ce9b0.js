(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{286:function(e,t,a){"use strict";a.r(t);var r=a(38),s=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域","aria-hidden":"true"}},[e._v("#")]),e._v(" 跨域")]),e._v(" "),a("h2",{attrs:{id:"tl-dr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tl-dr","aria-hidden":"true"}},[e._v("#")]),e._v(" TL;DR")]),e._v(" "),a("p",[a("code",[e._v("iframe,script,image")]),e._v("主要函数利用了 html 里面标签没有跨域的限制（他们仅仅能发送 get 请求），跨域限制是浏览器行为，限制的是脚本， html 标签没有限制。CORS 和 windows.postMessage 则是新提出来的方法")]),e._v(" "),a("h2",{attrs:{id:"ajax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax","aria-hidden":"true"}},[e._v("#")]),e._v(" AJAX")]),e._v(" "),a("p",[e._v("是一种能够向服务器请求额外的数据而无需卸载页面(无刷新)的技术，是对 Asynchronous Javascript + XML 的简写")]),e._v(" "),a("h3",{attrs:{id:"xmlhttprequest（不能跨域）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xmlhttprequest（不能跨域）","aria-hidden":"true"}},[e._v("#")]),e._v(" XMLHttpRequest（不能跨域）")]),e._v(" "),a("p",[e._v("属性")]),e._v(" "),a("p",[e._v("readyState（通过 onReadyStateChange 来监听它的变化）")]),e._v(" "),a("ul",[a("li",[e._v("0 UNSENT (未打开) open()方法还未被调用.")]),e._v(" "),a("li",[e._v("1 OPENED (未发送) open()方法已经被调用.")]),e._v(" "),a("li",[e._v("2 HEADERS_RECEIVED (已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回.")]),e._v(" "),a("li",[e._v("3 LOADING (正在下载响应体) 响应体下载中; responseText 中已经获取了部分数据.")]),e._v(" "),a("li",[e._v("4 DONE (请求完成) 整个请求过程已经完毕.")])]),e._v(" "),a("p",[e._v("responseXML：对请求的响应，解析为 XML 并作为 Document 对象返回。")]),e._v(" "),a("p",[e._v("responseText：响应体（不包括头部）")]),e._v(" "),a("p",[e._v("status：由服务器返回的 HTTP 状态代码，如 200 表示成功")]),e._v(" "),a("p",[e._v("statusText：这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。")]),e._v(" "),a("p",[e._v("方法")]),e._v(" "),a("p",[e._v("abort() : 取消当前响应，关闭连接并且结束任何未决的网络活动。\ngetAllResponseHeaders()：把 HTTP 响应头部作为未解析的字符串返回。\ngetResponseHeader()：返回指定的 HTTP 响应头部的值。\nopen()：初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求。\nsend()：发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。\nsetRequestHeader()：向一个打开但未发送的请求设置或添加一个 HTTP 请求。")]),e._v(" "),a("h2",{attrs:{id:"跨域方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域方法","aria-hidden":"true"}},[e._v("#")]),e._v(" 跨域方法")]),e._v(" "),a("p",[e._v("浏览器限制从脚本内发起的跨域 HTTP 请求（也可能是返回结果被浏览器拦截了）")]),e._v(" "),a("p",[e._v("只要协议，域名，端口有任何一个不同，都会被当成一个不同的域，跨域限制是浏览器行为")]),e._v(" "),a("h3",{attrs:{id:"iframe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iframe","aria-hidden":"true"}},[e._v("#")]),e._v(" iframe")]),e._v(" "),a("p",[e._v("首先需要把发送给 web 服务器的数据编码到 URL 中,然后设置 iframe 的 src 属性为该 URL，服务器能创建一个包含响应内容的 HTML 文档")]),e._v(" "),a("h3",{attrs:{id:"图像-ping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图像-ping","aria-hidden":"true"}},[e._v("#")]),e._v(" 图像 Ping")]),e._v(" "),a("p",[e._v("image 标签")]),e._v(" "),a("p",[e._v("就是发送一个 get 请求")]),e._v(" "),a("h3",{attrs:{id:"jsonp-json-with-padding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsonp-json-with-padding","aria-hidden":"true"}},[e._v("#")]),e._v(" JSONP( JSON with padding )")]),e._v(" "),a("p",[e._v("动态添加"),a("code",[e._v("<script>")]),e._v("标签来调用服务器提供的 js 脚本")]),e._v(" "),a("p",[e._v("首先要明确的是 JSONP 就是一个 get 请求，请求类型这样:"),a("code",[e._v("http://www.example.net/sample.aspx?callback=mycallback")])]),e._v(" "),a("p",[e._v("如果不是 JSONP，他可能就是返回这样的数据："),a("code",[e._v("{ foo: 'bar' }")])]),e._v(" "),a("p",[e._v("JOSNP 的请求，服务端会获取 url 里面的 callback，把 JSON 放在这个 callback 里面，然后返回类似这样"),a("code",[e._v("mycallback({ foo: 'bar' });")]),e._v("，然后开发者在自己的页面里面定义 mycallback 函数，当这个脚本加载之后，这个函数就会执行")]),e._v(" "),a("h3",{attrs:{id:"cors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cors","aria-hidden":"true"}},[e._v("#")]),e._v(" CORS")]),e._v(" "),a("p",[e._v("首部字段 "),a("code",[e._v("Access-Control-Allow-Methods")]),e._v(" 表明服务器允许客户端使用 POST, GET 和 OPTIONS 方法发起请求。该字段与 HTTP/1.1 Allow: response header 类似，但仅限于在需要访问控制的场景中使用。")]),e._v(" "),a("p",[e._v("首部字段 "),a("code",[e._v("Access-Control-Allow-Headers")]),e._v(" 表明服务器允许请求中携带字段 X-PINGOTHER 与 Content-Type。与 Access-Control-Allow-Methods 一样，Access-Control-Allow-Headers 的值为逗号分割的列表。")]),e._v(" "),a("p",[e._v("最后，首部字段 "),a("code",[e._v("Access-Control-Max-Age")]),e._v(" 表明该响应的有效时间为 86400 秒，也就是 24 小时。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。")]),e._v(" "),a("p",[e._v("CORS 需要客户端和服务器同时支持。目前，所有浏览器都支持该机制。")]),e._v(" "),a("p",[e._v("跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。")]),e._v(" "),a("h3",{attrs:{id:"window-postmessage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#window-postmessage","aria-hidden":"true"}},[e._v("#")]),e._v(" window.postMessage()")]),e._v(" "),a("p",[e._v("只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。")]),e._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/04/cors.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("跨域资源共享 CORS 详解"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://stackoverflow.com/questions/2067472/what-is-jsonp-and-why-was-it-created",target:"_blank",rel:"noopener noreferrer"}},[e._v("What is JSONP, and why was it created?"),a("OutboundLink")],1)])])])},[],!1,null,null,null);t.default=s.exports}}]);