(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{466:function(e,o,s){"use strict";s.r(o);var r=s(42),t=Object(r.a)({},(function(){var e=this,o=e.$createElement,s=e._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),s("h2",{attrs:{id:"模块解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块解析"}},[e._v("#")]),e._v(" 模块解析")]),e._v(" "),s("p",[e._v("指编译器所要依据的一个流程，用它来找出某个导入操作所引用的具体值")]),e._v(" "),s("h2",{attrs:{id:"导入方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#导入方式"}},[e._v("#")]),e._v(" 导入方式")]),e._v(" "),s("ul",[s("li",[e._v("相对导入")])]),e._v(" "),s("p",[e._v("相对于导入他的文件来的，并不能解析为一个外部模块声明（一般用于自己写的模块）")]),e._v(" "),s("ul",[s("li",[e._v("非相对导入")])]),e._v(" "),s("p",[e._v("相对于 baseUrl 或者通过路径映射来进行解析")]),e._v(" "),s("h2",{attrs:{id:"模块解析策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块解析策略"}},[e._v("#")]),e._v(" 模块解析策略")]),e._v(" "),s("h3",{attrs:{id:"服务端-commonjs-规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务端-commonjs-规范"}},[e._v("#")]),e._v(" 服务端 CommonJS 规范")]),e._v(" "),s("p",[e._v("NodeJS 使用的规范,"),s("strong",[e._v("同步")]),e._v(" ，用于服务端")]),e._v(" "),s("h4",{attrs:{id:"相对路径解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相对路径解析"}},[e._v("#")]),e._v(" 相对路径解析")]),e._v(" "),s("p",[e._v('相对路径很简单。 例如，假设有一个文件路径为 /root/src/moduleA.js，包含了一个导入 var x = require("./moduleB"); Node.js 以下面的顺序解析这个导入：')]),e._v(" "),s("ul",[s("li",[s("p",[e._v("将/root/src/moduleB.js 视为文件，检查是否存在。")])]),e._v(" "),s("li",[s("p",[e._v('将/root/src/moduleB 视为目录，检查是否它包含 package.json 文件并且其指定了一个"main"模块。 在我们的例子里，如果 Node.js 发现文件 /root/src/moduleB/package.json 包含了{ "main": "lib/mainModule.js" }，那么 Node.js 会引用/root/src/moduleB/lib/mainModule.js。')])]),e._v(" "),s("li",[s("p",[e._v('将/root/src/moduleB 视为目录，检查它是否包含 index.js 文件。 这个文件会被隐式地当作那个文件夹下的"main"模块。')])])]),e._v(" "),s("h4",{attrs:{id:"非相对模块名解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非相对模块名解析"}},[e._v("#")]),e._v(" 非相对模块名解析")]),e._v(" "),s("p",[e._v('还是用上面例子，但假设/root/src/moduleA.js 里使用的是非相对路径导入 var x = require("moduleB");。 Node 则会以下面的顺序去解析 moduleB，直到有一个匹配上。')]),e._v(" "),s("p",[e._v("/root/src/node_modules/moduleB.js")]),e._v(" "),s("p",[e._v('/root/src/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),s("p",[e._v("/root/src/node_modules/moduleB/index.js")]),e._v(" "),s("p",[e._v("/root/node_modules/moduleB.js（向上跳了一级目录）")]),e._v(" "),s("p",[e._v('/root/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),s("p",[e._v("/root/node_modules/moduleB/index.js")]),e._v(" "),s("p",[e._v("/node_modules/moduleB.js（向上跳了一级目录）")]),e._v(" "),s("p",[e._v('/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),s("p",[e._v("/node_modules/moduleB/index.js")]),e._v(" "),s("p",[e._v("Node 会在一个特殊的文件夹 node_modules 里查找你的模块。 node_modules 可能与当前文件在同一级目录下，或者在上层目录里。 Node 会向上级目录遍历，查找每个 node_modules 直到它找到要加载的模块。")]),e._v(" "),s("h3",{attrs:{id:"定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),s("p",[e._v("允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。")]),e._v(" "),s("p",[e._v("1、exports 是指向的 module.exports 的引用")]),e._v(" "),s("p",[e._v("2、module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}")]),e._v(" "),s("p",[e._v("3、require() 返回的是 module.exports 而不是 exports")]),e._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://juejin.im/post/5aaa37c8f265da23945f365c",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端模块化：CommonJS,AMD,CMD,ES6"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);o.default=t.exports}}]);