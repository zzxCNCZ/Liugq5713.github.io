(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{287:function(t,a,r){"use strict";r.r(a);var e=r(38),s=Object(e.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"关键渲染路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关键渲染路径","aria-hidden":"true"}},[t._v("#")]),t._v(" 关键渲染路径")]),t._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[t._v("解释")]),t._v(" "),r("p",[t._v("关键渲染路径(Critical Rendering Path)：是指浏览器呈现网页要经历的一系列步骤")])]),t._v(" "),r("p",[t._v("PS： Google 的"),r("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=zh-cn",target:"_blank",rel:"noopener noreferrer"}},[t._v("关键渲染路径文档"),r("OutboundLink")],1),t._v("写的是真的好")]),t._v(" "),r("h2",{attrs:{id:"html-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#html-dom","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML -> DOM")]),t._v(" "),r("p",[t._v("字节 → 字符 → 令牌 → 节点 → 对象模型，生成了文档对象模型")]),t._v(" "),r("p",[t._v("HTML response > Tokens > Nodes > DOM Tree")]),t._v(" "),r("p",[t._v("浏览器会"),r("strong",[t._v("逐步构建 DOM")]),t._v(",通过这一点来优化生成网页的速度。即不用等所有 HTML 的都好了之后在处理，返回部分 HTML 是个很好的性能优化策略")]),t._v(" "),r("h2",{attrs:{id:"css-cssom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css-cssom","aria-hidden":"true"}},[t._v("#")]),t._v(" CSS -> CSSOM")]),t._v(" "),r("p",[t._v("不能使用 CSS 部分树，因为 CSS 会依据层级关系重新定义和优化样式属性，这个规则是我们能够更改 CSS 树。")]),t._v(" "),r("p",[t._v("如果使用 CSS 部分树，会导致网页的样式渲染不正常。所以浏览器会组织呈现，直到收到并处理了所有的 CSS 内容。即 CSS 为一种渲染阻塞资源(render blocking resource)")]),t._v(" "),r("p",[r("strong",[t._v("CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间")])]),t._v(" "),r("h2",{attrs:{id:"render-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-tree","aria-hidden":"true"}},[t._v("#")]),t._v(" Render Tree")]),t._v(" "),r("p",[t._v("渲染树(CSSOM 树和 DOM 树合并)最重要的特性就是仅捕获可见内容。渲染树是 DOM 和 CSSOM 的结合，是最终能渲染到页面的元素的树形结构表示。也就是说，它包含能在"),r("strong",[t._v("页面中最终呈现的元素")]),t._v("，而不包含那些用 CSS 样式隐藏的元素，比如带有 display: none;属性的元素。")]),t._v(" "),r("h2",{attrs:{id:"layout"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#layout","aria-hidden":"true"}},[t._v("#")]),t._v(" Layout")]),t._v(" "),r("p",[t._v("根据渲染树来布局，以计算每个节点的几何信息,将各个节点绘制到屏幕上")]),t._v(" "),r("p",[r("code",[t._v('<meta name="viewport" content="width=device-width, initial-scale=1">')])]),t._v(" "),r("p",[t._v("告诉浏览器布局视口的宽度应该等于设备的宽度，如果没有设置，浏览器就会使用默认视口宽度 980px")]),t._v(" "),r("hr"),t._v(" "),r("h2",{attrs:{id:"javascript"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript")]),t._v(" "),r("p",[t._v("JavaScript 允许我们修改网页的方方面面：内容、样式以及它如何响应用户交互。 不过，"),r("strong",[t._v("JavaScript 也会阻止 DOM 构建和延缓网页渲染")])]),t._v(" "),r("ul",[r("li",[t._v("JavaScript 可以查询和修改 DOM 与 CSSOM")]),t._v(" "),r("li",[t._v("JavaScript 执行会阻止 CSSOM。")]),t._v(" "),r("li",[t._v("除非将 JavaScript 显式声明为异步，否则它会阻止构建 DOM")])]),t._v(" "),r("h3",{attrs:{id:"javascript-为什么放在页面底部"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-为什么放在页面底部","aria-hidden":"true"}},[t._v("#")]),t._v(" Javascript 为什么放在页面底部")]),t._v(" "),r("p",[t._v("我们的脚本在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。")]),t._v(" "),r("p",[t._v("换言之，我们的脚本块找不到网页中任何靠后的元素，因为它们尚未接受处理！或者，稍微换个说法：执行我们的内联脚本会阻止 DOM 构建，也就延缓了首次渲染。")]),t._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[t._v("如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，会怎样？")]),t._v(" "),r("p",[t._v("答案很简单，对性能不利：浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建")]),t._v(" "),r("p",[t._v("向 script 标记添加异步关键字可以指示浏览器在等待脚本可用期间不阻止 DOM 构建，这样可以显著提升性能，eg: "),r("code",[t._v('<script src="app.js" async><\/script>')])])])])},[],!1,null,null,null);a.default=s.exports}}]);