(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{397:function(t,a,e){"use strict";e.r(a);var r=e(42),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),e("h2",{attrs:{id:"服务端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端路由"}},[t._v("#")]),t._v(" 服务端路由")]),t._v(" "),e("p",[t._v("每跳转到不同的 URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回 HTML，也可以是直接返回模板 HTML，然后由前端 JS 再去请求数据，使用前端模板和数据进行组合，生成想要的 HTML。")]),t._v(" "),e("h2",{attrs:{id:"前端路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端路由"}},[t._v("#")]),t._v(" 前端路由")]),t._v(" "),e("p",[t._v("每跳转到不同的 URL 都是使用前端的锚点路由，实际上只是 JS 根据 URL 来操作 DOM 元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合，当然模板有可能是请求服务端返回的，这就是 SPA 单页程序。")]),t._v(" "),e("h3",{attrs:{id:"改变-hash-值，监听-onhashchange-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#改变-hash-值，监听-onhashchange-事件"}},[t._v("#")]),t._v(" 改变 hash 值，监听 onhashchange 事件")]),t._v(" "),e("p",[t._v("是通过改变 hash 值，监听 onhashchange 事件，这种方式的优点是可以兼容低版本浏览器。Web 服务器并不会解析 "),e("code",[t._v("hash")]),t._v("，也就是说 "),e("code",[t._v("#")]),t._v(" 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 "),e("code",[t._v("window.location.hash")]),t._v(" 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。")]),t._v(" "),e("h3",{attrs:{id:"histroyapi，监听-popstate-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#histroyapi，监听-popstate-事件"}},[t._v("#")]),t._v(" histroyAPI，监听 popState 事件")]),t._v(" "),e("p",[t._v("是通过 historyAPI ,监听 popState 事件，用 pushState 和 replaceState 来实现")]),t._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[t._v("使用路由。却返回 can't get /route")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://stackoverflow.com/questions/32098076/react-router-cannot-get-except-for-root-url",target:"_blank",rel:"noopener noreferrer"}},[t._v("问题详情"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("http://10.0.0.1/about 这样的路由向服务器寻找资源，所以需设置 historyApiFallback 为 true 。当使用 "),e("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/History",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTML5 History API"),e("OutboundLink")],1),t._v(" 时，任意的 "),e("code",[t._v("404")]),t._v(" 响应都可能需要被替代为 "),e("code",[t._v("index.html")]),t._v("。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);