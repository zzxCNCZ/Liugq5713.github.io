(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{390:function(e,a,t){"use strict";t.r(a);var r=t(42),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[e._v("#")]),e._v(" 缓存")]),e._v(" "),t("ul",[t("li",[e._v("缓存从三个功能来分： 是否缓存资源，是否使用本地缓存资源 ，向服务器验证过期资源")])]),e._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),t("blockquote",[t("p",[e._v("强缓存主要是通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制。Expire 是 HTTP1.0 标准下的字段")])]),e._v(" "),t("h3",{attrs:{id:"cache-control"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" Cache-Control")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("max-age（单位为 s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了。")])]),e._v(" "),t("li",[t("p",[e._v("s-maxage（单位为 s）同 max-age，只用于共享缓存（比如 CDN 缓存）。")])]),e._v(" "),t("li",[t("p",[e._v("public 指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定 public 还是 private，则默认为 public。")])]),e._v(" "),t("li",[t("p",[e._v("private 响应只作为私有的缓存，不能在用户间共享。如果要求 HTTP 认证，响应会自动设置为 private。")])]),e._v(" "),t("li",[t("p",[e._v("no-cache(他的意思不是说不使用缓存) ，他的意思是： revalidate with server 。 即在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证， 如果资源没有改变则会响应 304 并使用缓存副本")])]),e._v(" "),t("li",[t("p",[e._v("no-store 绝对禁止缓存")])])]),e._v(" "),t("h3",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[e._v("#")]),e._v(" Expires")]),e._v(" "),t("p",[e._v("缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点")]),e._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),t("p",[e._v("协商缓存一定会发请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源（304 not modified）")]),e._v(" "),t("h3",{attrs:{id:"last-modified-if-modified-since"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[e._v("#")]),e._v(" Last-Modified/If-Modified-Since")]),e._v(" "),t("p",[e._v("服务器端文件的最后修改时间，需要和 cache-control 共同使用，是检查服务器端资源是否更新的一种方式")]),e._v(" "),t("h3",{attrs:{id:"etag-if-none-match"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[e._v("#")]),e._v(" ETag/If-None-Match")]),e._v(" "),t("p",[e._v("ETag 是一个响应首部字段，它是根据实体内容生成的一段 hash 字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改")]),e._v(" "),t("h2",{attrs:{id:"前端实践"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端实践"}},[e._v("#")]),e._v(" 前端实践")]),e._v(" "),t("p",[e._v("在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了")]),e._v(" "),t("ul",[t("li",[e._v("hash：跟整个项目的构建相关，构建生成的文件 hash 值都是一样的，只要项目里有文件更改，整个项目构建的 hash 值都会更改")]),e._v(" "),t("li",[e._v("chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的 hash 值")]),e._v(" "),t("li",[e._v("contenthash：由文件内容产生的 hash 值，内容不同产生的 contenthash 值也不一样")])]),e._v(" "),t("h2",{attrs:{id:"localstorage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localstorage"}},[e._v("#")]),e._v(" LocalStorage")]),e._v(" "),t("p",[e._v("一种本地存储的公共资源，域名下很多应用共享这份资源会有风险；LocalStorage 是以页面域名划分的，如果有多个等价域名之间的 LocalStorage 不互通，则会造成缓存多份浪费")]),e._v(" "),t("h2",{attrs:{id:"sessionstorage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sessionstorage"}},[e._v("#")]),e._v(" SessionStorage")]),e._v(" "),t("p",[e._v("SessionStorage 的数据只存储到特定的会话中，不属于持久化的存储，所以关闭浏览器会清除数据")]),e._v(" "),t("h2",{attrs:{id:"cache-control-no-store-private"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-no-store-private"}},[e._v("#")]),e._v(" 'Cache-Control': 'no-store,private'")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.imperva.com/learn/performance/cache-control/",target:"_blank",rel:"noopener noreferrer"}},[e._v("cache-control 参考"),t("OutboundLink")],1)]),e._v(" "),t("ul",[t("li",[e._v("private")])]),e._v(" "),t("p",[e._v("Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache, such as a proxy server.")]),e._v(" "),t("ul",[t("li",[e._v("no-store")])]),e._v(" "),t("p",[e._v("The no-store directive means browsers aren’t allowed to cache a response and must pull it from the server each time it’s requested. This setting is usually used for sensitive data, such as personal banking details.")]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c136bd16fb9a049d37efc47",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端缓存最佳实践"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5a673af06fb9a01c927ed880",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器 HTTP 缓存机制"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://stackoverflow.com/questions/866822/why-both-no-cache-and-no-store-should-be-used-in-http-response",target:"_blank",rel:"noopener noreferrer"}},[e._v("Why both no-cache and no-store should be used in HTTP response?"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);