(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{332:function(e,r,a){"use strict";a.r(r);var o=a(38),s=Object(o.a)({},function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),a("h2",{attrs:{id:"模块解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块解析","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块解析")]),e._v(" "),a("p",[e._v("指编译器所要依据的一个流程，用它来找出某个导入操作所引用的具体值")]),e._v(" "),a("h2",{attrs:{id:"导入方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导入方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 导入方式")]),e._v(" "),a("ul",[a("li",[e._v("相对导入")])]),e._v(" "),a("p",[e._v("相对于导入他的文件来的，并不能解析为一个外部模块声明（一般用于自己写的模块）")]),e._v(" "),a("hr"),e._v(" "),a("ul",[a("li",[e._v("非相对导入")])]),e._v(" "),a("p",[e._v("相对于 baseUrl 或者通过路径映射来进行解析")]),e._v(" "),a("h2",{attrs:{id:"模块解析策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块解析策略","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块解析策略")]),e._v(" "),a("h3",{attrs:{id:"服务端-commonjs-规范-同步-，用于服务端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端-commonjs-规范-同步-，用于服务端","aria-hidden":"true"}},[e._v("#")]),e._v(" 服务端 CommonJS 规范( 同步 ，用于服务端)")]),e._v(" "),a("p",[e._v("NodeJS 使用的规范")]),e._v(" "),a("h4",{attrs:{id:"相对路径解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相对路径解析","aria-hidden":"true"}},[e._v("#")]),e._v(" 相对路径解析")]),e._v(" "),a("p",[e._v('相对路径很简单。 例如，假设有一个文件路径为 /root/src/moduleA.js，包含了一个导入 var x = require("./moduleB"); Node.js 以下面的顺序解析这个导入：')]),e._v(" "),a("ul",[a("li",[e._v("将/root/src/moduleB.js 视为文件，检查是否存在。")])]),e._v(" "),a("ul",[a("li",[e._v('将/root/src/moduleB 视为目录，检查是否它包含 package.json 文件并且其指定了一个"main"模块。 在我们的例子里，如果 Node.js 发现文件 /root/src/moduleB/package.json 包含了{ "main": "lib/mainModule.js" }，那么 Node.js 会引用/root/src/moduleB/lib/mainModule.js。')])]),e._v(" "),a("ul",[a("li",[e._v('将/root/src/moduleB 视为目录，检查它是否包含 index.js 文件。 这个文件会被隐式地当作那个文件夹下的"main"模块。')])]),e._v(" "),a("h4",{attrs:{id:"非相对模块名解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非相对模块名解析","aria-hidden":"true"}},[e._v("#")]),e._v(" 非相对模块名解析")]),e._v(" "),a("p",[e._v('还是用上面例子，但假设/root/src/moduleA.js 里使用的是非相对路径导入 var x = require("moduleB");。 Node 则会以下面的顺序去解析 moduleB，直到有一个匹配上。')]),e._v(" "),a("p",[e._v("/root/src/node_modules/moduleB.js")]),e._v(" "),a("p",[e._v('/root/src/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),a("p",[e._v("/root/src/node_modules/moduleB/index.js")]),e._v(" "),a("p",[e._v("/root/node_modules/moduleB.js（向上跳了一级目录）")]),e._v(" "),a("p",[e._v('/root/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),a("p",[e._v("/root/node_modules/moduleB/index.js")]),e._v(" "),a("p",[e._v("/node_modules/moduleB.js（向上跳了一级目录）")]),e._v(" "),a("p",[e._v('/node_modules/moduleB/package.json (如果指定了"main"属性)')]),e._v(" "),a("p",[e._v("/node_modules/moduleB/index.js")]),e._v(" "),a("p",[e._v("Node 会在一个特殊的文件夹 node_modules 里查找你的模块。 node_modules 可能与当前文件在同一级目录下，或者在上层目录里。 Node 会向上级目录遍历，查找每个 node_modules 直到它找到要加载的模块。")]),e._v(" "),a("h3",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),a("p",[e._v("允许模块通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。")]),e._v(" "),a("p",[e._v("1、exports 是指向的 module.exports 的引用")]),e._v(" "),a("p",[e._v("2、module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}")]),e._v(" "),a("p",[e._v("3、require() 返回的是 module.exports 而不是 exports")]),e._v(" "),a("h2",{attrs:{id:"浏览器端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器端","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器端")]),e._v(" "),a("h3",{attrs:{id:"amd（asynchronous-module-definition）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd（asynchronous-module-definition）","aria-hidden":"true"}},[e._v("#")]),e._v(" AMD（Asynchronous Module Definition）")]),e._v(" "),a("p",[e._v("require.js 基于此规范")]),e._v(" "),a("p",[e._v("对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。")]),e._v(" "),a("p",[e._v("提前执行")]),e._v(" "),a("h3",{attrs:{id:"cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmd","aria-hidden":"true"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),a("p",[e._v("SeaJS 基于此规范")]),e._v(" "),a("p",[e._v("二者区别")]),e._v(" "),a("p",[e._v("CMD 推崇依赖就近，AMD 推崇依赖前置。")]),e._v(" "),a("h3",{attrs:{id:"es6-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6 模块")]),e._v(" "),a("p",[e._v("尽可能的静态化（模块语法的限制）")]),e._v(" "),a("p",[e._v("export 和 import 的一个限制是 必须在其他语句和函数之外使用")])])},[],!1,null,null,null);r.default=s.exports}}]);