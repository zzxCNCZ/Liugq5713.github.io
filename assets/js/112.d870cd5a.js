(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{372:function(t,a,s){"use strict";s.r(a);var e=s(38),n=Object(e.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"拆包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拆包","aria-hidden":"true"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://hackernoon.com/the-100-correct-way-to-split-your-chunks-with-webpack-f8a9df5b7758",target:"_blank",rel:"noopener noreferrer"}},[t._v("拆包"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("根据 "),s("a",{attrs:{href:"https://webpack.js.org/glossary/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Webpack glossary"),s("OutboundLink")],1),t._v("，有两种拆包策略")]),t._v(" "),s("ul",[s("li",[t._v("Bundle Splitting：创建更多的较小的文件，方便缓存")])]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("Bundle")]),t._v(" "),s("p",[t._v("Produced from a number of distinct modules, bundles contain the final versions of source files that have already undergone the loading and compilation process.")])]),t._v(" "),s("ul",[s("li",[t._v("Code Splitting：动态加载代码，用户访问时仅需加载需要的代码")])]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("Chunks")]),t._v(" "),s("p",[t._v("This webpack-specific term is used internally to manage the bundling process. Bundles are composed out of chunks, of which there are several types (e.g. entry and child). Typically, chunks directly correspond with the output bundles however, there are some configurations that don't yield a one-to-one relationship.")])]),t._v(" "),s("h2",{attrs:{id:"bundle-splitting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bundle-splitting","aria-hidden":"true"}},[t._v("#")]),t._v(" Bundle Splitting")]),t._v(" "),s("p",[t._v("这里主要是和缓存有关，如果你有一个巨大的文件，改动了一行代码，整个文件就必须要更新，但是如果你将他拆分成两个文件，你仅仅需要更新修改了的文件。Bundle Splitting 对于缓存十分的有用")]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("from memory cache vs from disk cache")]),t._v(" "),s("p",[t._v("from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –> disk。在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。")])]),t._v(" "),s("h3",{attrs:{id:"防止重复打包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#防止重复打包","aria-hidden":"true"}},[t._v("#")]),t._v(" 防止重复打包")]),t._v(" "),s("ul",[s("li",[t._v("启用拆分")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("optimization"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  splitChunks"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    chunks"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'all'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("optimization.splitChunks.chunks = 'all'")]),t._v(" "),s("p",[t._v("put everything in node_modules into a file called vendors~main.js")])]),t._v(" "),s("ul",[s("li",[t._v("拆分每个 npm 包")])]),t._v(" "),s("p",[t._v("我们的 vendors.js 遇到了与我们原来的 main.js 文件相同的问题 - 对其中一部分的更改意味着重新下载它的所有部分。\n那么为什么不为每个 npm 包提供单独的文件呢？这很容易做到。")]),t._v(" "),s("h2",{attrs:{id:"code-splitting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#code-splitting","aria-hidden":"true"}},[t._v("#")]),t._v(" Code Splitting")]),t._v(" "),s("h3",{attrs:{id:"路由懒加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载","aria-hidden":"true"}},[t._v("#")]),t._v(" 路由懒加载")]),t._v(" "),s("h3",{attrs:{id:"资源预加载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#资源预加载","aria-hidden":"true"}},[t._v("#")]),t._v(" 资源预加载")]),t._v(" "),s("p",[s("code",[t._v("import(/* webpackPrefetch: true */ 'LoginModal');")])]),t._v(" "),s("p",[t._v("这种写法将会被 webpack 转为"),s("code",[t._v('<link rel="prefetch" href="login-modal-chunk.js">')]),t._v("，并添加到 head 标签里面。")]),t._v(" "),s("p",[t._v("Prefetch 专注于下一个页面将要加载的资源并以低优先级加载")])])},[],!1,null,null,null);a.default=n.exports}}]);